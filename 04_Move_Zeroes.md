# Move Zeroes (移動零)

## 題目描述

**目標：** 給你一個陣列 `nums`，請將所有的 `0` 移動到陣列的最後面，同時保持非零元素的相對順序。

**限制：** 必須在原陣列上操作 (In-place)，不能複製另外一個新的陣列（節省記憶體）。

---

## 硬體工程師視角

這題對應到 ASIC/FPGA 的場景非常經典：**記憶體壓縮 (Memory Compaction)** 或 **資料流打包 (Data Packing)**。

想像你從感測器收到一串資料流，中間夾雜著無效的 `0` (Null Data)，你的電路需要把有效的資料「緊密排列」存入記憶體，剩下的空間補零。

> [!NOTE]
> 這題的核心技巧叫做 **「雙指標 (Two Pointers)」**。這在硬體設計中，就是 **Read Pointer (讀取指標)** 與 **Write Pointer (寫入指標)** 的概念。

---

## 第一步：變數與具體例子 (Variables & Examples)

我們需要兩個指標（變數）來分別代表「寫入位置」和「讀取位置」。

### 1. `fast` (快指標 / 讀取頭)
- **用途：** 負責在前面探路，遍歷整個陣列，尋找「非零」的有效數字
- **硬體對應：** 就像是 **Input Data Stream** 的索引，一直往前掃描
- **例子：** 迴圈變數 `i`，從 `0` 跑到結束

### 2. `slow` (慢指標 / 寫入頭)
- **用途：** 永遠指向「下一個可以用來存放非零數字」的位置。只有當我們真的找到非零數字並把它放好後，這個指標才會往後移
- **硬體對應：** 就像是記憶體控制器的 **Write Address**
- **例子：** 初始值為 `0`。當我們處理陣列 `[0, 1, 0, 3]` 時，一開始 `slow` 指在索引 0，等著把 `1` 搬過來

---

## 第二步：演算法邏輯引導 (Algorithm Walkthrough)

我們採用 **「交換法 (Swap)」** 的策略。這就像是把非零的數字「氣泡」一路往前浮，把 `0` 沉下去。

### 執行過程模擬

**輸入：** `nums = [0, 1, 0, 3, 12]`

#### 初始化
- `slow = 0`

#### 第 1 輪 (fast 指向索引 0，數值 = 0)
- **數值：** `0`
- **判斷：** 是 0 嗎？是
- **動作：** 無效資料，跳過。`slow` 不動
- **陣列狀態：** `[0, 1, 0, 3, 12]` (沒變)
- **指標狀態：** `slow=0, fast=0`

#### 第 2 輪 (fast 指向索引 1，數值 = 1)
- **數值：** `1`
- **判斷：** 是 0 嗎？不是！ (發現有效資料)
- **動作：** 把 `nums[fast]` 跟 `nums[slow]` 交換
  - 把 `1` 換到位置 `0`
- **指標更新：** `slow` 往後移一格 (準備接下一個有效數字)
- **陣列狀態：** `[1, 0, 0, 3, 12]`
- **指標狀態：** `slow=1, fast=1`

#### 第 3 輪 (fast 指向索引 2，數值 = 0)
- **數值：** `0`
- **判斷：** 是 0，跳過
- **陣列狀態：** `[1, 0, 0, 3, 12]` (沒變)
- **指標狀態：** `slow=1, fast=2`

#### 第 4 輪 (fast 指向索引 3，數值 = 3)
- **數值：** `3`
- **判斷：** 非 0！交換
- **動作：** 把 `3` (位置 3) 跟 `0` (位置 1, 即 `slow` 所在) 交換
- **指標更新：** `slow` 往後移
- **陣列狀態：** `[1, 3, 0, 0, 12]`
- **指標狀態：** `slow=2, fast=3`

#### 第 5 輪 (fast 指向索引 4，數值 = 12)
- **數值：** `12`
- **判斷：** 非 0！交換
- **動作：** 把 `12` 跟 `0` (`slow` 位置) 交換
- **陣列狀態：** `[1, 3, 12, 0, 0]`
- **指標狀態：** `slow=3, fast=4`

#### 結束
`fast` 掃完了。你會發現，所有的非零數字都排在前面了，後面自然剩下的都是 `0`。

---

### 雙指標移動視覺化

```
初始: nums = [0, 1, 0, 3, 12]
             ↑
          slow, fast

Round 1: nums[fast] = 0, 跳過
             ↑
           slow
             
Round 2: nums[fast] = 1, 交換!
      [1, 0, 0, 3, 12]
          ↑
        slow (移動到 1)
        
Round 3: nums[fast] = 0, 跳過
      [1, 0, 0, 3, 12]
          ↑
        slow
        
Round 4: nums[fast] = 3, 交換!
      [1, 3, 0, 0, 12]
             ↑
           slow (移動到 2)
           
Round 5: nums[fast] = 12, 交換!
      [1, 3, 12, 0, 0]
                ↑
              slow (移動到 3)

最終結果: [1, 3, 12, 0, 0] ✓
```

---

## 第三步：Python 程式碼實作

這段程式碼展示了如何用單一迴圈完成「讀取」與「寫入/交換」的同步操作。

```python
def moveZeroes(nums):
    # 1. 初始化慢指標 (Write Pointer)，指向下一個存放非零數的位置
    slow = 0
    
    # 2. 快指標 (fast) 負責遍歷整個陣列
    # 使用 range(len(nums)) 取得索引
    for fast in range(len(nums)):
        
        # 3. 只有當快指標找到「非零」元素時，才需要做事
        # 對應硬體概念：Valid Data Enable
        if nums[fast] != 0:
            
            # 4. 將非零元素交換到慢指標的位置
            # Python 的交換語法非常直觀： a, b = b, a
            nums[slow], nums[fast] = nums[fast], nums[slow]
            
            # 5. 慢指標任務完成，往後移一格，準備接下一個有效資料的位置
            slow += 1
            
    # 函式結束，nums 已經在原地被修改完成 (Pass by Reference)
```

---

## 第四步：復健重點分析 (Key Takeaways)

### 1. Python 的交換語法 (Swap)

```python
nums[slow], nums[fast] = nums[fast], nums[slow]
```

在 C/C++ 你需要一個 `temp` 變數來暫存，Python 幫你做掉了（背後其實是用 **Tuple Unpacking** 或是底層優化）。這行程式碼非常優雅。

### 2. 雙指標 (Read/Write Pointers)

這是在處理陣列時極為重要的思維。

| 指標 | 角色 | 硬體類比 |
|------|------|----------|
| **fast** | 讀取指標 | 就像你的 Clock Cycle，每個 cycle 都往下走 |
| **slow** | 寫入指標 | 就像你的 Counter，只有發生特定事件（Valid Data）時才計數 |

### 3. In-place Operation (原地操作)

題目規定不能 `return` 新陣列，這考驗你對記憶體位址的操作。

> [!IMPORTANT]
> 這跟硬體寫入 RAM 的行為完全一致：你是在**修改記憶體內容**，而不是創造新的記憶體。

---

## 時間與空間複雜度

- **時間複雜度：** $O(n)$ - 只需遍歷一次陣列
- **空間複雜度：** $O(1)$ - 只使用兩個指標變數，常數空間

---

## 硬體電路類比

```
┌─────────────────────────────────────────────────────┐
│  Memory Compaction Circuit                          │
│                                                      │
│  Input Stream: [0, 1, 0, 3, 12]                     │
│                 ↓  ↓  ↓  ↓  ↓                       │
│         ┌───────────────────┐                       │
│         │  Valid Data Check │                       │
│         │   (nums[i] != 0)  │                       │
│         └─────────┬─────────┘                       │
│                   │                                  │
│         ┌─────────▼─────────┐                       │
│  slow → │ Write Enable Logic│ ← fast (Read Ptr)     │
│         └─────────┬─────────┘                       │
│                   │                                  │
│         ┌─────────▼─────────┐                       │
│         │  Memory Array      │                       │
│         │  [1, 3, 12, 0, 0] │                       │
│         └───────────────────┘                       │
│                                                      │
│  Control Signals:                                   │
│  - Valid Data → Write Enable = 1                    │
│  - Zero Data  → Write Enable = 0                    │
└─────────────────────────────────────────────────────┘
```

---

## 常見變形

這個雙指標技巧可以應用在很多情境：

| 題目變形 | 說明 | 修改方式 |
|----------|------|----------|
| **移除特定值** | 移除所有等於 `val` 的元素 | 把條件改成 `if nums[fast] != val` |
| **移除重複元素** | 排序陣列中移除重複項 | 比較 `nums[fast]` 和 `nums[slow-1]` |
| **分離奇偶數** | 偶數在前，奇數在後 | 把條件改成 `if nums[fast] % 2 == 0` |

---

## 額外練習：兩種寫法比較

### 寫法一：交換法 (本題採用)
```python
def moveZeroes(nums):
    slow = 0
    for fast in range(len(nums)):
        if nums[fast] != 0:
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow += 1
```

### 寫法二：覆蓋法 + 填零
```python
def moveZeroes(nums):
    slow = 0
    # 第一階段：把非零元素覆蓋到前面
    for fast in range(len(nums)):
        if nums[fast] != 0:
            nums[slow] = nums[fast]
            slow += 1
    
    # 第二階段：剩下的位置全部填 0
    for i in range(slow, len(nums)):
        nums[i] = 0
```

兩種方法時間複雜度相同，但交換法只需要一次遍歷，程式碼更簡潔！
