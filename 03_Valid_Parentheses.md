# Valid Parentheses (有效的括號)

## 題目描述

**目標：** 給你一個只包含 `(`, `)`, `{`, `}`, `[`, `]` 的字串 `s`，判斷這個字串的括號配對是否合法。

**規則：**
1. 左括號必須用相同類型的右括號閉合
2. 左括號必須以正確的順序閉合（不能像 `([)]` 這樣交錯）

---

## 第一步：變數與具體例子 (Variables & Examples)

我們需要一個容器來暫存我們遇到的「左括號」。

### 1. `stack` (堆疊 / 串列)
- **用途：** 在 Python 中，我們直接用 List `[]` 來當作 Stack。我們只把「左括號」存進去，等待未來的「右括號」來消掉它。
- **操作：**
  - `append()` 等於 **Push** (入堆疊)
  - `pop()` 等於 **Pop** (出堆疊)
- **例子：** 目前讀到字串 `"{["`，Stack 裡面就會長這樣：`['{', '[']` (最右邊是頂端)

### 2. `mapping` (配對表 / 字典)
- **用途：** 這是為了快速查找「右括號對應誰」。我們習慣把右括號當作 Key，左括號當作 Value。**為什麼？** 因為我們是讀到右括號時，才去查表確認它是否合法。
- **結構：** `{ 右括號 : 左括號 }`
- **具體內容：** `{ ')': '(', ']': '[', '}': '{' }`

### 3. `char` (當前字元)
- **用途：** 迴圈目前讀到的那個括號。
- **例子：** 字串 `s = "()"，第一輪 `char` 是 `(`，第二輪 `char` 是 `)`

---

## 第二步：演算法邏輯引導 (Algorithm Walkthrough)

### 執行過程模擬

**輸入：** `s = "{[]}"`  → 這是合法的

#### 初始化
- `stack = []`
- 準備好 `mapping` 表

#### 第 1 輪 (讀入 `{`)
- **判斷：** 它是右括號嗎？不是
- **動作：** 它是左括號，把它 Push 進 stack
- **Stack 狀態：** `['{']`

#### 第 2 輪 (讀入 `[`)
- **判斷：** 它是右括號嗎？不是
- **動作：** Push 進 stack
- **Stack 狀態：** `['{', '[']` (注意：`[` 在最上面，要先被處理)

#### 第 3 輪 (讀入 `]`)
- **判斷：** 它是右括號嗎？是！ (`]` 在 mapping 的 Key 裡)
- **檢查堆疊：**
  - Stack 是空的嗎？不空
  - Stack 最上面那個 (top element) 是它的另一半嗎？
    - Stack 最上面是 `[`
    - 查表 `mapping[']']` 應該要是 `[`
    - **配對成功！**
- **動作：** 把 Stack 最上面的 `[` Pop 掉（消掉）
- **Stack 狀態：** `['{']`

#### 第 4 輪 (讀入 `}`)
- **判斷：** 它是右括號嗎？是！
- **檢查堆疊：**
  - Stack 最上面是 `{`
  - 查表 `mapping['}']` 應該要是 `{`
  - **配對成功！**
- **動作：** 把 `{` Pop 掉
- **Stack 狀態：** `[]` (空的)

#### 結束檢查
- 確保 Stack 是空的（代表所有左括號都找到了歸宿）
- **Return：** `True`

---

### Stack 操作視覺化

```
輸入: "{[]}"

Step 1: 讀入 '{'          Step 2: 讀入 '['
┌─────┐                 ┌─────┐
│     │                 │  [  │ ← Top
├─────┤                 ├─────┤
│  {  │ ← Top           │  {  │
└─────┘                 └─────┘

Step 3: 讀入 ']'         Step 4: 讀入 '}'
配對 '[' 和 ']'         配對 '{' 和 '}'
┌─────┐                 ┌─────┐
│  {  │ ← Top           │     │ ← Empty!
└─────┘                 └─────┘
Pop '[' ✓               Pop '{' ✓

結果: Stack 為空 → Valid!
```

---

## 第三步：Python 程式碼實作

這段程式碼展示了如何用 Python 的 List 模擬 Stack 行為。

```python
def isValid(s):
    # 1. 建立配對表，用來檢查「右括號」是否對應正確的「左括號」
    # Key 是右括號 (我們遇到的 Closing Tag)，Value 是左括號 (我們期待在 Stack 頂端的東西)
    mapping = {')': '(', ']': '[', '}': '{'}
    
    # 2. 初始化堆疊 (使用 Python List)
    stack = []
    
    # 3. 遍歷字串中的每一個字元
    for char in s:
        
        # 4. 如果 char 是右括號 (存在於 mapping 的 keys 中)
        if char in mapping:
            
            # 5. 我們要從 Stack 拿最上面的元素出來比對
            # 如果 stack 是空的 (代表只有右括號卻沒有左括號)，給一個 dummy value '#' 避免報錯
            top_element = stack.pop() if stack else '#'
            
            # 6. 比對：拿出來的東西，跟我們期待的左括號 (mapping[char]) 一樣嗎？
            if top_element != mapping[char]:
                return False
        
        else:
            # 7. 如果 char 是左括號，直接放入堆疊等待配對
            stack.append(char)
    
    # 8. 最後檢查：Stack 必須是空的才算完全合法
    # 如果還有剩 (例如 "{[")，代表有左括號沒被閉合，return False
    # Python 寫法： return not stack (如果 stack 空回傳 True)
    return not stack
```

---

## 第四步：復健重點分析 (Key Takeaways)

### 1. List 作為 Stack

在 C++ 你可能要用 `std::stack`，但在 Python，`list` 本身就是 Stack。

| 操作 | Python List | 說明 |
|------|-------------|------|
| **Push** | `list.append(x)` | 將元素加到最後 |
| **Pop** | `list.pop()` | 移除並回傳最後一個元素 |
| **Peek** | `list[-1]` | 只看最上面是誰，不移除 |
| **isEmpty** | `not list` 或 `len(list) == 0` | 檢查是否為空 |

### 2. Corner Cases (邊界測試)

寫驗證腳本時最怕這種 bug：

> [!WARNING]
> **只有右括號：** `"]"` → 程式會在 pop 時因為空 list 而報錯（所以程式碼裡寫了 `if stack else '#'` 的保護機制）
> 
> **只有左括號：** `"["` → 迴圈跑完沒報錯，但最後 Stack 不為空，這也是錯的

### 3. ASIC 應用場景

這跟你寫 Verilog Testbench 時的 **FIFO (First-In, First-Out)** 不同，這是 **LIFO (Last-In, First-Out)**。

但在做以下場景時，這就是標準解法：
- **Regex (正規表達式) 處理 Log 檔**
- **Python 腳本去 check `begin ... end` 區塊是否對稱**
- **解析 Verilog/SystemVerilog 的巢狀結構**

---

## 常見測試案例

| 輸入 | 輸出 | 說明 |
|------|------|------|
| `"()"` | `True` | 基本配對 |
| `"()[]{}"` | `True` | 多種括號，正確順序 |
| `"(]"` | `False` | 類型不匹配 |
| `"([)]"` | `False` | 交錯順序 |
| `"{[]}"` | `True` | 巢狀結構，正確配對 |
| `"((("` | `False` | 只有左括號 |
| `")))"` | `False` | 只有右括號 |
| `""` | `True` | 空字串視為有效 |

---

## 時間與空間複雜度

- **時間複雜度：** $O(n)$ - 需要遍歷整個字串，每個字元處理一次
- **空間複雜度：** $O(n)$ - 最壞情況下（全是左括號），Stack 需要存儲所有字元

---

## LIFO vs FIFO 對照

```
LIFO (Stack) - 本題使用          FIFO (Queue) - 不同應用
┌─────────────┐                 ┌─────────────┐
│    Push     │                 │   Enqueue   │
│      ↓      │                 │      ↓      │
│   ┌───┐     │                 │   ┌───┬───┬───┐
│   │ C │ ← Top                 │   │ A │ B │ C │
│   ├───┤     │                 │   └───┴───┴───┘
│   │ B │     │                 │    ↑       ↑
│   ├───┤     │                 │   Front   Rear
│   │ A │     │                 │      │
│   └───┘     │                 │   Dequeue
│      ↑      │                 │
│     Pop     │                 │
└─────────────┘                 └─────────────┘
先進後出 (本題)                  先進先出 (BFS)
```
