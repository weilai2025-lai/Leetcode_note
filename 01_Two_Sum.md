# Two Sum (兩數之和)

## 題目描述

**目標：** 給你一個整數陣列 `nums` 和一個目標值 `target`，請你在陣列中找出兩個數字，相加等於 `target`，並回傳這兩個數字的「索引位置 (Index)」。

---

## 第一步：變數與具體例子 (Variables & Examples)

在寫程式前，我們先把腦中的變數具象化。這是你要求的「變數＋具體例子」風格：

### 1. `nums` (輸入陣列)
- **用途：** 這是我們要搜索的資料來源。
- **例子：** 假設 `nums = [2, 7, 11, 15]`
  - 索引 0 是 `2`
  - 索引 1 是 `7`
  - 索引 2 是 `11`
  - ... 以此類推

### 2. `target` (目標總和)
- **用途：** 我們希望找到兩個數相加等於這個值。
- **例子：** 假設 `target = 9`

### 3. `seen_map` (查表紀錄 / 字典)
- **用途：** 這是一個 Python 的 dictionary。它的功能是當我們「路過」一個數字時，把這個數字跟它的索引記下來，方便回頭查找。
- **結構：** `{ 看過的數字 : 它的索引 }`
- **例子：** 如果我們剛讀過數字 `2` (位於索引 0)，這個變數就會變成 `{ 2 : 0 }`

### 4. `diff` (差值 / 補數)
- **用途：** 這是我們「缺」的那個數字。算法的核心是：我看著現在手中的數字，去查表看有沒有它的「另一半」。
- **例子：** 目前的數字是 `7`，目標是 `9`。那 `diff` 就是 `9 - 7 = 2`。我們只要去查 `seen_map` 裡面有沒有 `2` 就可以了。

---

## 第二步：演算法邏輯引導 (Algorithm Walkthrough)

我們採用 **一次遍歷 (One-pass)** 的方法。這就像你在產線 (Pipeline) 上，東西過來一個，你就處理一個，不需要把整條產線停下來重看兩遍。

### 執行過程模擬

**輸入：** `nums = [2, 7, 11, 15]`, `target = 9`

#### 初始化
- 準備一個空的本子 `seen_map = {}`

#### 第 1 輪迴圈 (i=0)
1. **拿到數字：** `num = 2`
2. **計算差值 (diff)：** 我想要湊到 9，所以我缺 `9 - 2 = 7`
3. **查表：** 查一下 `seen_map` 裡面有沒有 `7`？
4. **結果：** 目前是空的，沒有
5. **紀錄：** 把現在手上的 `2` 記下來，並寫下它的位置
   - `seen_map` 更新為：`{ 2 : 0 }`

#### 第 2 輪迴圈 (i=1)
1. **拿到數字：** `num = 7`
2. **計算差值 (diff)：** 我想要湊到 9，所以我缺 `9 - 7 = 2`
3. **查表：** 查一下 `seen_map` 裡面有沒有 `2`？
4. **結果：** 有！ (剛剛第一輪存進去的)
5. **找到答案：** 立刻回傳 `2` 的索引 (查表得來是 `0`) 和現在 `7` 的索引 (現在是 `1`)
6. **Return：** `[0, 1]`

---

## 第三步：Python 程式碼實作

現在試著閱讀這段程式碼，看看能不能跟上面的邏輯對上。

```python
def twoSum(nums, target):
    # 1. 建立一個空的字典 (Hash Map) 來儲存看過的數字與索引
    # 對應硬體概念：就像初始化一塊空的 Memory
    seen_map = {}
    
    # 2. 使用 enumerate 函式同時取得索引 (i) 和數值 (num)
    # 例子：當跑到 nums[0] 時，i=0, num=2
    for i, num in enumerate(nums):
        
        # 3. 計算我們需要的「另一半」數值 (Difference)
        # 例子：如果 target=9, num=7，則 diff=2
        diff = target - num
        
        # 4. 檢查這個 diff 是否已經存在於我們的紀錄 (seen_map) 中
        # 對應硬體概念：這就像是一個 Cache Hit (快取命中)
        if diff in seen_map:
            # 5. 如果找到了，回傳 [diff的舊索引, 現在的索引]
            return [seen_map[diff], i]
        
        # 6. 如果沒找到，把現在的數字與索引存入字典，供未來查找
        # 結構：seen_map[數值] = 索引
        seen_map[num] = i
        
    # 如果跑完整個迴圈都沒找到 (題目保證會有解，所以這邊通常不會執行到)
    return []
```

---

## 第四步：復健重點分析 (Key Takeaways)

### 1. `enumerate(nums)`
這在 Python 很常用。當你需要同時知道「我現在在哪裡 (Index)」和「我現在拿著什麼值 (Value)」時，不要用 `range(len(nums))`，用 `enumerate` 更優雅。

### 2. 字典查找 (`if diff in seen_map`)
這是 Python 效能強大的原因。它的時間複雜度是 **$O(1)$**，也就是說不管資料量多大，查找速度幾乎一樣快。這就像硬體中的 **LUT (Look-Up Table)**，輸入地址，資料馬上出來，不需要從頭掃描。

### 3. 邏輯轉換
過去你可能習慣寫兩層迴圈 (Nested Loop) 硬找，但在 ASIC 設計中，我們也很講究 **Latency (延遲)**。用 **空間換取時間 (Space-Time Tradeoff)** 是軟硬體通用的優化法則：
- 我們多用了一個 `seen_map` 的記憶體空間
- 換來了只跑一趟迴圈的高速效能

---

## 時間與空間複雜度

- **時間複雜度：** $O(n)$ - 只需遍歷一次陣列
- **空間複雜度：** $O(n)$ - 最壞情況下需要存儲 n-1 個元素在 hash map 中
