# Single Number (只出現一次的數字)

## 題目描述

**目標：** 給你一個非空的整數陣列 `nums`，除了某個元素只出現一次以外，其餘每個元素均出現兩次。請找出那個只出現一次的元素。

**限制：** 你必須設計一個線性時間複雜度 $O(n)$ 的演算法，並且只使用常數的額外空間 $O(1)$。

---

## 第一步：變數與具體例子 (Variables & Examples)

我們需要一個變數來當作「暫存器 (Register)」。

### 1. `nums` (輸入訊號)
- **用途：** 輸入的數據流。
- **例子：** `nums = [4, 1, 2, 1, 2]`
  - 這裡有兩對數字：`1` 和 `2`
  - 只有 `4` 是落單的

### 2. `xor_reg` (累加暫存器)
- **用途：** 這就像你在 Verilog 裡宣告一個 `reg [31:0] xor_reg`。我們會把所有讀進來的數字跟這個變數做 **XOR (互斥或)** 運算。
- **初始值：** `0` (因為任何數跟 0 做 XOR 還是它自己)
- **例子：** 一開始是 `0`，隨著迴圈進行，它會儲存「目前為止所有數字 XOR 的結果」

---

## 第二步：演算法邏輯引導 (Algorithm Walkthrough)

這裡的核心概念是 **XOR (Exclusive OR)** 運算，在 Python 裡的符號跟 Verilog 一樣，都是 `^`。

### ASIC/FPGA 工程師的直覺

回想一下 XOR 的真值表 (Truth Table) 和特性：

1. **歸零律：** $A \oplus A = 0$ (兩個一樣的訊號相減/互斥，會抵銷成 0)
2. **恆等律：** $A \oplus 0 = A$ (任何訊號跟 0 做 XOR，保持原樣)
3. **交換律：** $A \oplus B \oplus A = A \oplus A \oplus B = 0 \oplus B = B$ (順序不重要)

### 執行過程模擬

**輸入：** `nums = [4, 1, 2, 1, 2]`

我們的策略是：**把所有數字全部 XOR 起來**。成雙成對的數字會互相抵銷變成 0，最後剩下的那個，就是落單的數字。

#### 初始化
- `xor_reg = 0`

#### 第 1 輪 (讀入 4)
- **運算：** `0 ^ 4`
- **xor_reg 更新為：** `4` (二進位 `100`)

#### 第 2 輪 (讀入 1)
- **運算：** `4 ^ 1`
- **xor_reg 更新為：** `5` (二進位 `101`)
  - 這時候人類看不懂，沒關係，電腦知道就好

#### 第 3 輪 (讀入 2)
- **運算：** `5 ^ 2`
- **xor_reg 更新為：** `7` (二進位 `111`)

#### 第 4 輪 (讀入 1) → 關鍵時刻！
- **運算：** `7 ^ 1`
- **邏輯：** 這裡的 `1` 會去跟第 2 輪進來的那個 `1` 互相抵銷
- **xor_reg 更新為：** `6` (二進位 `110`)

#### 第 5 輪 (讀入 2) → 再次抵銷！
- **運算：** `6 ^ 2`
- **邏輯：** 這裡的 `2` 會去跟第 3 輪進來的那個 `2` 互相抵銷
- **xor_reg 更新為：** `4` (二進位 `100`)

#### 結果
陣列跑完了，`xor_reg` 裡留下的就是那個沒被抵銷掉的 **`4`**。

---

## 第三步：Python 程式碼實作

這段程式碼非常簡潔，跟硬體描述語言 (HDL) 的行為非常像。

```python
def singleNumber(nums):
    # 1. 初始化一個變數作為「暫存器」，初始值設為 0
    # 對應硬體概念：Reset 訊號拉起時，Register 歸零
    xor_reg = 0
    
    # 2. 遍歷每一個數字 (num)
    # 對應硬體概念：Data Stream (資料流) 一個一個進來
    for num in nums:
        
        # 3. 執行 XOR 運算並更新暫存器
        # Python 的 ^= 運算子等同於 xor_reg = xor_reg ^ num
        # 對應 Verilog： always @(posedge clk) xor_reg <= xor_reg ^ num;
        xor_reg ^= num
        
    # 4. 最後暫存器裡剩下的值，就是唯一的那個數字
    return xor_reg
```

---

## 第四步：復健重點分析 (Key Takeaways)

### 1. 位元運算子 (Bitwise Operators)

Python 的位元運算符號跟 C/C++/Verilog 幾乎通用：

| 運算子 | 功能 | 範例 |
|-------|------|------|
| `&` | AND | `a & b` |
| `\|` | OR | `a \| b` |
| `^` | XOR | `a ^ b` |
| `~` | NOT | `~a` |
| `<<` | Left Shift (左移) | `a << 2` |
| `>>` | Right Shift (右移) | `a >> 2` |

> [!IMPORTANT]
> 在 Python 中做邏輯判斷 (True/False) 是用 `and`, `or`, `not`，但做數值位元運算是用符號。這點新手容易搞混。

### 2. 空間複雜度 $O(1)$

上一題 Two Sum 我們用了 Dictionary (Hash Map)，那是用空間換時間。這一題我們只用了一個變數 `xor_reg`，就像電路裡只用了一組 **Flip-Flops**，非常節省資源。這符合硬體設計中 **Area Efficient (面積效益)** 的思維。

### 3. Python 的 for 迴圈簡寫

如果只關心數值不關心索引，直接寫 `for num in nums:` 最乾淨，不需要 `range` 或 `enumerate`。

---

## 時間與空間複雜度

- **時間複雜度：** $O(n)$ - 只需遍歷一次陣列
- **空間複雜度：** $O(1)$ - 只使用一個變數，常數空間

---

## 硬體設計類比

```
┌─────────────────────────────────────┐
│  XOR Single Number Detector         │
│                                     │
│  Input Stream: [4, 1, 2, 1, 2]     │
│         ↓                           │
│    ┌─────────┐                      │
│    │ XOR_REG │ ← Reset to 0         │
│    └─────────┘                      │
│         ↓                           │
│    Feedback Loop                    │
│    (每個 clk 更新)                  │
│         ↓                           │
│    Output: 4                        │
└─────────────────────────────────────┘
```

這個演算法可以直接對應到一個簡單的數位電路：
- 一個 Register 儲存中間結果
- 一個 XOR Gate 做運算
- 資料流式處理，不需要額外的記憶體
